package storage

import (
	"database/sql"
	"fmt"
	"os"
	"sort"
	"strings"
	"time"

	cclog "github.com/ClusterCockpit/cc-metric-collector/pkg/ccLogger"
	lp "github.com/ClusterCockpit/cc-metric-collector/pkg/ccMetric"
)

type ClusterStorage struct {
	Password string `json:"password"`
	handle   *sql.DB
	last_idx uint64
}

type StorageQuery struct {
	EventName  string    `json:"event"`
	Hostname   string    `json:"host"`
	From       time.Time `json:"from"`
	To         time.Time `json:"to"`
	Type       *string   `json:"type,omitempty"`
	SubType    *string   `json:"subtype,omitempty"`
	TypeIds    []string  `json:"type-ids,omitempty"`
	SubTypeIds []string  `json:"subtype-ids,omitempty"`
}

func queryToSql(query StorageQuery) (string, []interface{}) {
	s := "select * from events where hostname == ? and timestamp >= ? and timestamp <= ?"
	args := []interface{}{query.Hostname, query.From, query.To}
	if query.Type != nil {
		s += " and type == ?"
		args = append(args, *query.Type)
		if len(query.TypeIds) > 0 {
			tlist := make([]string, 0)
			for _, tid := range query.TypeIds {
				tlist = append(tlist, fmt.Sprintf("typeid == %s", tid))
			}
			s += " and (" + strings.Join(tlist, " or ") + ")"
		}
	}
	if query.SubType != nil {
		s += " and stype == ?"
		args = append(args, *query.SubType)
		if len(query.SubTypeIds) > 0 {
			tlist := make([]string, 0)
			for _, tid := range query.SubTypeIds {
				tlist = append(tlist, fmt.Sprintf("stypeid == %s", tid))
			}
			s += " and (" + strings.Join(tlist, " or ") + ")"
		}
	}
	return s, args
}

type storage struct {
	Basefolder string
	Databases  map[string]ClusterStorage
}

type Storage interface {
	Close()
	NewCluster(cluster string) error
	WriteCluster(cluster string, event lp.CCMetric) error
	QueryCluster(cluster string, query StorageQuery) (*[]lp.CCMetric, error)
}

const createTableStmt = `create table events (id integer not null primary key, timestamp timestamp, name text, hostname text, type text, typeid text, stype text, stypeid text, othertags text, event text);`
const insertStmt = `insert into events(id, timestamp, name, hostname, type, typeid, stype, stypeid, othertags, event) values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`
const (
	EVENT_FIELD_KEY  = `event`
	HOSTNAME_TAG_KEY = `hostname`
	TYPE_TAG_KEY     = `type`
	TYPEID_TAG_KEY   = `type-id`
	STYPE_TAG_KEY    = `stype`
	STYPEID_TAG_KEY  = `stype-id`
)

func (s *storage) init(basefolder string) error {
	if info, err := os.Stat(basefolder); err == nil {
		if !info.IsDir() {
			err := fmt.Errorf("%s exists but is no folder", basefolder)
			cclog.ComponentError("Storage", err.Error())
			return err
		}
	} else {
		err = os.MkdirAll(basefolder, 0700)
		if err != nil {
			cclog.ComponentError("Storage", "Failed creating base folder:", err.Error())
			return err
		}
	}
	s.Basefolder = basefolder
	s.Databases = make(map[string]ClusterStorage)
	return nil
}

func (s *storage) Close() {
	for cluster, cs := range s.Databases {
		cs.handle.Close()
		delete(s.Databases, cluster)
	}
}

func (s *storage) NewCluster(cluster string) error {
	db, err := sql.Open("sqlite3", fmt.Sprintf("%s.db", cluster))
	if err != nil {
		cclog.ComponentError("Storage", "Failed to create database", fmt.Sprintf("%s.db", cluster))
		return err
	}
	_, err = db.Exec(createTableStmt)
	if err != nil {
		cclog.ComponentError("Storage", fmt.Sprintf("%q: %s", err, createTableStmt))
		return err
	}
	// TODO: Get last_idx
	s.Databases[cluster] = ClusterStorage{
		handle:   db,
		last_idx: 0,
	}
	return nil
}

func (s *storage) WriteCluster(cluster string, event lp.CCMetric) error {
	if cs, ok := s.Databases[cluster]; ok {
		tx, err := cs.handle.Begin()
		if err != nil {
			cclog.ComponentError("Storage", err.Error())
			return err
		}
		cclog.ComponentDebug("Storage", "Preparing insert statement for cluster", cluster)
		stmt, err := tx.Prepare(insertStmt)
		if err != nil {
			cclog.ComponentError("Storage", err.Error())
			return err
		}
		defer stmt.Close()
		if ev, ok := event.GetField(EVENT_FIELD_KEY); ok {
			args := make([]interface{}, 0)
			args = append(args, cs.last_idx+1, event.Time(), event.Name())
			if h, ok := event.GetTag(HOSTNAME_TAG_KEY); ok {
				args = append(args, h)
			} else {
				err = fmt.Errorf("event has no %s tag", HOSTNAME_TAG_KEY)
				return err
			}
			type_tag, ok := event.GetTag(TYPE_TAG_KEY)
			if ok {
				args = append(args, type_tag)
			} else {
				err = fmt.Errorf("event has no %s tag", TYPE_TAG_KEY)
				return err
			}
			if h, ok := event.GetTag(TYPEID_TAG_KEY); ok {
				args = append(args, h)
			} else {
				if type_tag == "node" {
					args = append(args, "0")
				} else {
					err = fmt.Errorf("event has no %s tag", TYPEID_TAG_KEY)
					return err
				}
			}
			stype_tag, ok := event.GetTag(STYPE_TAG_KEY)
			if ok {
				args = append(args, stype_tag)
			} else {
				args = append(args, nil)
			}
			if len(stype_tag) > 0 {
				if stypeid_tag, ok := event.GetTag(STYPEID_TAG_KEY); ok {
					args = append(args, stypeid_tag)
				} else {
					args = append(args, nil)
				}
			}
			othertags := make([]string, 0)
			for k, v := range event.Tags() {
				switch k {
				case HOSTNAME_TAG_KEY, TYPE_TAG_KEY, TYPEID_TAG_KEY, STYPE_TAG_KEY, STYPEID_TAG_KEY:
				default:
					othertags = append(othertags, fmt.Sprintf("%s=%s", k, v))
				}
			}
			sort.Strings(othertags)
			args = append(args, strings.Join(othertags, ","), ev)
			_, err = stmt.Exec(args...)
			if err != nil {
				cclog.ComponentError("Storage", err.Error())
				return err
			}
			err = tx.Commit()
			if err != nil {
				cclog.ComponentError("Storage", err.Error())
				return err
			}
			cs.last_idx++
		}
	} else {
		err := fmt.Errorf("database for cluster %s does not exist", cluster)
		return err
	}
	return nil
}

func (s *storage) QueryCluster(cluster string, query StorageQuery) (*[]lp.CCMetric, error) {
	out := make([]lp.CCMetric, 0)
	if _, ok := s.Databases[cluster]; !ok {
		err := fmt.Errorf("database for cluster %s does not exist", cluster)
		return nil, err
	}

	sqlstr, args := queryToSql(query)

	rows, err := s.Databases[cluster].handle.Query(sqlstr, args...)
	if err != nil {
		cclog.ComponentError("Storage", err.Error())
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		var id int
		var name string
		var timestamp time.Time
		var hostname string
		var tagtype string
		var typeid string
		var stagtype string
		var stypeid string
		var othertags string
		var event string
		err = rows.Scan(&id, &timestamp, &name, &hostname, &tagtype, &typeid, &stagtype, &stypeid, &othertags, &event)
		if err != nil {
			cclog.ComponentError("Storage", err.Error())
			return nil, err
		}
		y, err := lp.New(name, map[string]string{
			"hostname": hostname,
			"type":     tagtype,
			"type-id":  typeid,
		}, map[string]string{}, map[string]interface{}{EVENT_FIELD_KEY: event}, timestamp)
		if err != nil {
			cclog.ComponentError("Storage", err.Error())
			return nil, err
		}
		if len(stagtype) > 0 {
			y.AddTag("stype", stagtype)
		}
		if len(stypeid) > 0 {
			y.AddTag("stype-id", stypeid)
		}
		otags := strings.Split(othertags, ",")
		for _, t := range otags {
			vals := strings.SplitN(t, "=", 1)
			if len(vals) == 2 {
				y.AddTag(vals[0], vals[1])
			}
		}
		cclog.ComponentDebug("Storage", y.String())
	}
	return &out, nil
}

func NewStorage(basefolder string) (Storage, error) {
	s := new(storage)

	err := s.init(basefolder)
	if err != nil {
		return nil, err
	}

	return s, nil
}
